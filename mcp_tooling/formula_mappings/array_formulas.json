{
  "array_sum": {
    "polars": "df.select(pl.col('col1') + pl.col('col2'))",
    "sheets": "=ARRAYFORMULA({range1} + {range2})",
    "validation": "tolerance_0.001",
    "complexity_level": "moderate",
    "description": "Element-wise addition of two arrays"
  },
  "array_multiply": {
    "polars": "df.select(pl.col('col1') * pl.col('col2'))",
    "sheets": "=ARRAYFORMULA({range1} * {range2})",
    "validation": "tolerance_0.001",
    "complexity_level": "moderate",
    "description": "Element-wise multiplication of two arrays"
  },
  "array_divide": {
    "polars": "df.select(pl.col('col1') / pl.col('col2'))",
    "sheets": "=ARRAYFORMULA({range1} / {range2})",
    "validation": "tolerance_0.001",
    "complexity_level": "moderate",
    "description": "Element-wise division of two arrays"
  },
  "array_if": {
    "polars": "df.select(pl.when(pl.col('condition')).then(pl.col('true_val')).otherwise(pl.col('false_val')))",
    "sheets": "=ARRAYFORMULA(IF({condition_range}, {true_range}, {false_range}))",
    "validation": "exact_match",
    "complexity_level": "moderate",
    "description": "Conditional array formula"
  },
  "filter": {
    "polars": "df.filter(pl.col('column') == criteria)",
    "sheets": "=FILTER({range}, {criteria_range}={criteria})",
    "validation": "exact_match",
    "complexity_level": "moderate",
    "description": "Filter array based on criteria"
  },
  "unique": {
    "polars": "df['column'].unique()",
    "sheets": "=UNIQUE({range})",
    "validation": "exact_match",
    "complexity_level": "moderate",
    "description": "Get unique values from array"
  },
  "sort": {
    "polars": "df.sort('column')",
    "sheets": "=SORT({range}, {sort_column}, {is_ascending})",
    "validation": "exact_match",
    "complexity_level": "moderate",
    "description": "Sort array by column"
  },
  "transpose": {
    "polars": "df.transpose()",
    "sheets": "=TRANSPOSE({range})",
    "validation": "exact_match",
    "complexity_level": "moderate",
    "description": "Transpose array (rows to columns)"
  },
  "sequence": {
    "polars": "pl.int_range(start, end, step)",
    "sheets": "=SEQUENCE({rows}, {columns}, {start}, {step})",
    "validation": "exact_match",
    "complexity_level": "moderate",
    "description": "Generate sequence of numbers"
  },
  "array_sum_product": {
    "polars": "(df['col1'] * df['col2']).sum()",
    "sheets": "=SUMPRODUCT({range1}, {range2})",
    "validation": "tolerance_0.001",
    "complexity_level": "moderate",
    "description": "Sum of products of corresponding array elements"
  },
  "lookup_array": {
    "polars": "df.join(lookup_df, on='key', how='left')",
    "sheets": "=ARRAYFORMULA(VLOOKUP({lookup_range}, {table_range}, {col_index}, FALSE))",
    "validation": "exact_match",
    "complexity_level": "complex",
    "description": "Array-based lookup operation"
  },
  "array_match": {
    "polars": "df['column'].map_elements(lambda x: lookup_dict.get(x, default))",
    "sheets": "=ARRAYFORMULA(MATCH({lookup_range}, {search_range}, 0))",
    "validation": "exact_match",
    "complexity_level": "moderate",
    "description": "Find positions of values in array"
  },
  "array_index": {
    "polars": "df.select(pl.col('column').list.get(index))",
    "sheets": "=ARRAYFORMULA(INDEX({range}, {row_nums}, {col_num}))",
    "validation": "exact_match",
    "complexity_level": "moderate",
    "description": "Get values at specific array positions"
  },
  "flatten": {
    "polars": "df.select(pl.col('list_column').list.explode())",
    "sheets": "=FLATTEN({range1}, {range2})",
    "validation": "exact_match",
    "complexity_level": "moderate",
    "description": "Flatten array into single column"
  },
  "array_frequency": {
    "polars": "df['column'].value_counts()",
    "sheets": "=ARRAYFORMULA(FREQUENCY({data_range}, {bins_range}))",
    "validation": "exact_match",
    "complexity_level": "complex",
    "description": "Calculate frequency distribution"
  }
}